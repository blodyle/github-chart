<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Contribution Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #0d1117;
        color: #e6edf3;
        line-height: 1.6;
        min-height: 100vh;
        margin: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(#30363d4d 1px, transparent 1px),
          linear-gradient(90deg, #30363d4d 1px, transparent 1px),
          linear-gradient(#30363d1a 1px, transparent 1px),
          linear-gradient(90deg, #30363d1a 1px, transparent 1px);
        background-size: 120px 120px, 120px 120px, 24px 24px, 24px 24px;
        background-position: 0 0, 0 0, 0 0, 0 0;
        pointer-events: none;
        z-index: -1;
      }

      body.app-active {
        display: flex;
      }

      .app-container {
        display: flex;
        width: 100%;
        min-height: 100vh;
      }

      .sidebar {
        width: 320px;
        background: #161b224d;
        padding: 20px;
        overflow-y: auto;
        flex-shrink: 0;
        backdrop-filter: blur(10px);
      }

      .main-content {
        flex: 1;
        padding: 12px;
        overflow-x: auto;
      }

      .welcome-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
      }

      .welcome-content {
        max-width: 600px;
        padding: 48px;
        background: #161b2266;
        backdrop-filter: blur(20px);
        border-radius: 20px;
        animation: welcomeSlideIn 0.4s ease-out;
        transition: all 0.5s ease;
      }

      @keyframes welcomeSlideIn {
        from {
          opacity: 0;
          transform: translateY(30px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .welcome-screen.loading .welcome-content {
        transform: scale(0.98);
        opacity: 0.8;
      }

      .welcome-screen.success .welcome-content {
        background: #161b22e6;
        box-shadow: 0 0 30px #2ea04333;
      }

      .welcome-screen.fade-out {
        opacity: 0;
        transform: scale(1.05);
        transition: all 0.6s ease;
      }

      .app-container {
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.6s ease;
      }

      .app-container.fade-in {
        opacity: 1;
        transform: translateY(0);
      }

      .header {
        text-align: center;
        margin-bottom: 24px;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        color: #f0f6fc;
      }

      .header p {
        color: #8b949e;
        font-size: 1.1rem;
      }

      .input-section {
        background: #161b224d;
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 24px;
      }

      .input-group {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      input[type="text"] {
        flex: 1;
        min-width: 200px;
        padding: 14px 18px;
        background: #0d1117cc;
        border: none;
        border-radius: 10px;
        color: #e6edf3;
        font-size: 16px;
        transition: all 0.2s;
      }

      input[type="text"]:focus {
        outline: none;
        background: #0d1117e6;
        box-shadow: 0 0 0 2px #58a6ff4d;
      }

      input[type="text"]::placeholder {
        color: #8b949e;
      }

      .btn {
        padding: 14px 26px;
        background: #238636;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s;
      }

      .btn:hover {
        background: #2ea043;
        transform: translateY(-1px);
      }

      .btn:disabled {
        background: #30363d;
        cursor: not-allowed;
      }

      .controls {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        align-items: center;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .control-group label {
        color: #f0f6fc;
        font-weight: 500;
        white-space: nowrap;
      }

      select {
        padding: 10px 14px;
        background: transparent;
        border: none;
        border-radius: 8px;
        color: #e6edf3;
        font-size: 14px;
      }

      select:focus {
        outline: none;
        box-shadow: 0 0 0 2px #58a6ff4d;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: #58a6ff;
      }

      .chart-container {
        background: transparent;
        border-radius: 16px;
        padding: 20px;
        margin-bottom: 20px;
        min-height: 400px;
        display: none;
      }

      .chart-container.active {
        display: block;
      }

      .chart-wrapper {
        position: relative;
        height: 400px;
        margin-top: 20px;
      }

      .loading {
        text-align: center;
        padding: 40px;
        color: #8b949e;
      }

      .error {
        background: #161b22cc;
        border-radius: 12px;
        padding: 24px;
        margin: 20px 0;
        color: #f85149;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 24px;
        margin-bottom: 24px;
      }

      .stat-card {
        background: transparent;
        border-radius: 12px;
        padding: 24px;
        text-align: center;
        backdrop-filter: blur(10px);
      }

      .stat-value {
        font-size: 2rem;
        font-weight: bold;
        color: #58a6ff;
        margin-bottom: 5px;
      }

      .stat-label {
        color: #8b949e;
        font-size: 0.9rem;
      }

      .comparison-stats {
        background: #161b224d;
        border-radius: 16px;
        padding: 20px;
        margin-bottom: 20px;
        backdrop-filter: blur(10px);
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        background: #0d111733;
        border-radius: 12px;
        overflow: hidden;
      }

      .comparison-table th,
      .comparison-table td {
        padding: 16px 20px;
        text-align: left;
        border-bottom: 1px solid #30363d4d;
      }

      .comparison-table th {
        background: #161b22cc;
        color: #f0f6fc;
        font-weight: 600;
      }

      .comparison-table td {
        color: #e6edf3;
      }

      .comparison-table tr:last-child td {
        border-bottom: none;
      }

      .metric-icon {
        margin-right: 8px;
        font-size: 1.1em;
      }

      .user-better {
        color: #26a641;
        font-weight: 600;
      }

      .user-worse {
        color: #f85149;
      }

      /* User Cards */
      .user-card {
        background: #0d111766;
        border-radius: 16px;
        padding: 20px;
        margin-bottom: 16px;
        position: relative;
        backdrop-filter: blur(10px);
        transition: background 0.2s ease;
      }

      .user-card:hover {
        background: #161b2280;
      }

      .user-card.primary {
        background: #161b2280;
        box-shadow: 0 0 0 1px #58a6ff33;
      }

      .user-card.comparison {
        background: #161b224d;
      }

      .user-header {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        margin-bottom: 12px;
      }

      .user-name {
        text-decoration: none;
      }

      .user-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 2px solid #58a6ff4d;
        flex-shrink: 0;
      }

      .user-info {
        flex: 1;
        min-width: 0;
      }

      .user-info h3 {
        color: #f0f6fc;
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 2px 0;
      }

      .user-info .username {
        color: #8b949e;
        font-size: 14px;
        margin: 0 0 6px 0;
      }

      .user-bio {
        color: #e6edf3;
        font-size: 13px;
        line-height: 1.4;
        margin: 8px 0;
        opacity: 0.9;
      }

      .user-location {
        color: #8b949e;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 4px;
        margin-bottom: 8px;
      }

      .user-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 12px 0 8px 0;
      }

      .user-stat {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        color: #8b949e;
      }

      .user-stat-value {
        color: #58a6ff;
        font-weight: 500;
      }

      .user-links {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        align-items: center;
      }

      .user-link {
        color: #8b949e;
        text-decoration: none;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 6px;
        background: #30363d4d;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .user-link:hover {
        color: #58a6ff;
        background: #58a6ff1a;
      }

      .user-join-date {
        color: #6e7681;
        font-size: 11px;
        margin-top: 8px;
        font-style: italic;
      }

      .user-actions {
        display: flex;
        gap: 6px;
        margin-top: 8px;
      }

      .icon-btn {
        background: #161b22cc;
        border: none;
        border-radius: 8px;
        padding: 8px;
        cursor: pointer;
        color: #8b949e;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .icon-btn:hover {
        background: #30363d99;
        color: #e6edf3;
      }

      .icon-btn.danger:hover {
        background: #da3633;
        color: white;
      }

      /* Add User Section */
      .add-user-section {
        margin-top: 20px;
      }

      .add-user-input {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .add-user-input input {
        flex: 1;
        padding: 10px 14px;
        background: #0d1117cc;
        border: none;
        border-radius: 8px;
        color: #e6edf3;
        font-size: 14px;
      }

      .add-user-input input:focus {
        outline: none;
        background: #0d1117e6;
        box-shadow: 0 0 0 2px #58a6ff4d;
      }

      /* Metrics Grid */
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-bottom: 16px;
      }

      .metric-card {
        background: #161b224d;
        border-radius: 16px;
        padding: 20px;
        text-align: center;
        transition: transform 0.2s ease, background 0.2s ease;
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
      }

      .metric-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: #58a6ff;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .metric-icon {
        width: 40px;
        height: 40px;
        color: #58a6ff;
        margin: 0 auto 16px;
        display: block;
      }

      .metric-value {
        font-size: 2.5rem;
        font-weight: bold;
        color: #f0f6fc;
        margin-bottom: 8px;
        line-height: 1;
      }

      .metric-label {
        color: #8b949e;
        font-size: 1rem;
        font-weight: 500;
        margin-bottom: 4px;
      }

      .metric-subtitle {
        color: #6e7681;
        font-size: 0.85rem;
        margin-top: 6px;
        font-style: italic;
      }

      /* Chart Type Cards */
      .chart-type-selector {
        display: flex;
        gap: 16px;
        margin-bottom: 24px;
        flex-wrap: wrap;
      }

      .chart-type-card {
        background: transparent;
        border-radius: 12px;
        padding: 16px 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 120px;
        justify-content: center;
      }

      .chart-type-card:hover {
        border-color: #58a6ff99;
        transform: translateY(-1px);
      }

      .chart-type-card.active {
        border-color: #58a6ffcc;
        box-shadow: 0 0 0 1px #58a6ff66;
      }

      .chart-type-card .icon {
        width: 20px;
        height: 20px;
        color: #8b949e;
        transition: color 0.2s ease;
      }

      .chart-type-card:hover .icon,
      .chart-type-card.active .icon {
        color: #58a6ff;
      }

      .chart-type-card .label {
        color: #e6edf3;
        font-weight: 500;
        font-size: 14px;
      }

      /* Charts */
      .chart-section {
        background: #161b224d;
        border-radius: 16px;
        padding: 20px;
        backdrop-filter: blur(10px);
        margin-bottom: 20px;
      }

      /* Custom Chart Legend */
      .chart-legend {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 8px;
        background: #30363d4d;
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .legend-item:hover {
        background: #30363d80;
      }

      .legend-item.hidden {
        opacity: 0.4;
      }

      .legend-avatar {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid;
        object-fit: cover;
      }

      .legend-text {
        color: #e6edf3;
        font-size: 14px;
        font-weight: 500;
      }

      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        flex-wrap: wrap;
        gap: 20px;
      }

      .chart-title {
        color: #f0f6fc;
        font-size: 1.2rem;
        font-weight: 600;
        margin: 0;
      }

      .chart-controls {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        align-items: center;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .control-group label {
        color: #f0f6fc;
        font-weight: 500;
        white-space: nowrap;
        font-size: 14px;
      }

      /* Welcome Screen */
      .welcome-title {
        font-size: 3rem;
        color: #f0f6fc;
        margin-bottom: 12px;
        font-weight: 700;
      }

      .welcome-subtitle {
        color: #8b949e;
        font-size: 1.1rem;
        margin-bottom: 32px;
        line-height: 1.6;
        max-width: 480px;
        margin-left: auto;
        margin-right: auto;
      }

      .welcome-input-group {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-bottom: 20px;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
      }

      .welcome-input-group input {
        width: 100%;
        padding: 18px 24px;
        background: #0d1117cc;
        border: none;
        border-radius: 12px;
        color: #e6edf3;
        font-size: 16px;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      .welcome-input-group input:focus {
        outline: none;
        background: #0d1117e6;
        box-shadow: 0 0 0 2px #58a6ff4d;
        transform: translateY(-1px);
      }

      .welcome-input-group input::placeholder {
        color: #8b949e;
        font-size: 15px;
      }

      .welcome-input-group .btn {
        padding: 18px 32px;
        font-size: 16px;
        font-weight: 600;
        border-radius: 12px;
        background: #238636;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .welcome-input-group .btn:hover {
        background: #2ea043;
        transform: translateY(-2px);
        box-shadow: 0 8px 25px #23863666;
      }

      .welcome-input-group .btn:active {
        transform: translateY(0);
      }

      /* Mobile Table Scroll Container */
      .table-scroll-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 8px;
        margin: 0 -4px;
        padding: 0 4px;
      }

      .table-scroll-container::-webkit-scrollbar {
        height: 8px;
      }

      .table-scroll-container::-webkit-scrollbar-track {
        background: #161b22;
        border-radius: 4px;
      }

      .table-scroll-container::-webkit-scrollbar-thumb {
        background: #30363d;
        border-radius: 4px;
      }

      .table-scroll-container::-webkit-scrollbar-thumb:hover {
        background: #484f58;
      }

      /* Responsive */
      @media (max-width: 768px) {
        body {
          padding: 0;
          margin: 0;
        }

        .app-container {
          flex-direction: column;
          padding: 0;
          margin: 0;
        }

        .sidebar {
          width: 100%;
          border-right: none;
          border-bottom: 1px solid #30363d;
          padding: 8px;
        }

        .main-content {
          padding: 8px;
        }

        .welcome-content {
          padding: 24px;
          margin: 16px;
          max-width: 90vw;
        }

        .welcome-title {
          font-size: 2.2rem;
        }

        .welcome-subtitle {
          font-size: 1rem;
        }

        .welcome-input-group {
          gap: 14px;
          max-width: 100%;
        }

        .welcome-input-group input {
          padding: 14px 18px;
          font-size: 16px;
        }

        .welcome-input-group .btn {
          padding: 14px 28px;
          font-size: 16px;
        }

        .btn {
          padding: 14px 20px;
          width: 100%;
          justify-content: center;
          display: flex;
          align-items: center;
        }

        .metrics-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 8px;
          margin-bottom: 12px;
        }

        .metric-card {
          padding: 12px;
        }

        .metric-value {
          font-size: 1.8rem;
        }

        .metric-label {
          font-size: 0.85rem;
        }

        .chart-header {
          flex-direction: column;
          align-items: stretch;
          gap: 12px;
        }

        .chart-controls {
          justify-content: space-between;
          flex-wrap: wrap;
          gap: 12px;
        }

        .control-group {
          flex-direction: column;
          align-items: stretch;
          gap: 6px;
          min-width: 100px;
          flex: 1;
        }

        .control-group label {
          font-size: 12px;
          text-align: center;
          font-weight: 600;
        }

        .control-group select {
          padding: 10px 8px;
          font-size: 14px;
          text-align: center;
          min-height: 44px;
        }

        .icon-btn {
          min-height: 44px;
          min-width: 44px;
          padding: 12px;
        }

        .chart-type-selector {
          justify-content: center;
          gap: 8px;
          flex-wrap: wrap;
        }

        .chart-type-card {
          min-width: 90px;
          padding: 10px 12px;
          flex: 1;
          max-width: 120px;
        }

        .chart-type-card .label {
          font-size: 12px;
        }

        .comparison-table {
          min-width: 400px;
          font-size: 14px;
        }

        .comparison-table th,
        .comparison-table td {
          padding: 8px 12px;
          white-space: nowrap;
        }

        .user-card {
          padding: 16px;
          margin-bottom: 12px;
        }

        .user-header {
          margin-bottom: 10px;
          gap: 10px;
        }

        .user-avatar {
          width: 40px;
          height: 40px;
        }

        .user-info h3 {
          font-size: 15px;
        }

        .user-info .username {
          font-size: 13px;
        }

        .user-bio {
          font-size: 12px;
          margin: 6px 0;
        }

        .user-stats {
          grid-template-columns: repeat(2, 1fr);
          gap: 6px;
          margin: 10px 0 6px 0;
        }

        .user-stat {
          font-size: 11px;
        }

        .user-links {
          gap: 6px;
          margin-top: 10px;
          flex-wrap: wrap;
        }

        .user-link {
          font-size: 11px;
          padding: 3px 6px;
        }

        .user-join-date {
          font-size: 10px;
          margin-top: 6px;
        }
      }

      /* Extra small mobile devices */
      @media (max-width: 480px) {
        .welcome-title {
          font-size: 1.6rem;
        }

        .metrics-grid {
          grid-template-columns: 1fr;
          gap: 8px;
        }

        .chart-type-selector {
          flex-direction: column;
          align-items: stretch;
        }

        .chart-type-card {
          max-width: none;
          min-width: 0;
          justify-content: flex-start;
          padding: 12px 16px;
        }

        .control-group {
          min-width: 80px;
        }

        .comparison-table {
          min-width: 350px;
          font-size: 13px;
        }

        .comparison-table th,
        .comparison-table td {
          padding: 6px 8px;
        }
      }

      /* Animations */
      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <!-- Welcome Screen -->
    <div id="welcomeScreen" class="welcome-screen">
      <div class="welcome-content">
        <h1 class="welcome-title">GitHub Contribution Chart</h1>
        <p class="welcome-subtitle">
          Visualize and compare GitHub contributions with interactive charts
        </p>

        <div class="welcome-input-group">
          <input
            type="text"
            id="githubHandle"
            placeholder="Enter GitHub username"
          />
          <button
            id="loadProfileBtn"
            class="btn"
            onclick="fetchContributions()"
          >
            <i
              data-lucide="github"
              id="loadProfileIcon"
              style="width: 16px; height: 16px; margin-right: 8px"
            ></i>
            Load Profile
          </button>
        </div>

        <div id="error" class="error" style="display: none"></div>
      </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="app-container" style="display: none">
      <!-- Sidebar -->
      <div class="sidebar">
        <div
          style="
            color: #8b949e;
            margin-bottom: 16px;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
          "
        >
          Users
        </div>

        <div id="usersList"></div>

        <div class="add-user-section">
          <button
            class="btn"
            onclick="toggleAddUser()"
            style="
              width: 100%;
              justify-content: center;
              display: flex;
              align-items: center;
            "
          >
            <i
              data-lucide="user-plus"
              style="width: 16px; height: 16px; margin-right: 8px"
            ></i>
            Add User for Comparison
          </button>

          <div id="addUserInput" class="add-user-input" style="display: none">
            <input
              type="text"
              id="compareHandle"
              placeholder="Enter username"
            />
            <button
              class="icon-btn"
              onclick="fetchComparisonData()"
              title="Add User"
            >
              <i data-lucide="plus" style="width: 16px; height: 16px"></i>
            </button>
            <button class="icon-btn" onclick="toggleAddUser()" title="Cancel">
              <i data-lucide="x" style="width: 16px; height: 16px"></i>
            </button>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Metrics Section -->
        <div class="chart-section">
          <div class="chart-header">
            <div
              style="
                color: #8b949e;
                font-size: 0.9rem;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
              "
            >
              Statistics
            </div>
          </div>

          <div id="metricsSection" class="metrics-grid">
            <!-- Metrics will be populated by JavaScript -->
          </div>
        </div>

        <!-- Chart Section -->
        <div class="chart-section">
          <div class="chart-header">
            <div
              style="
                color: #8b949e;
                font-size: 0.9rem;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
              "
            >
              Contribution Chart
            </div>

            <div class="chart-controls">
              <div class="control-group">
                <label for="dateRange">Range:</label>
                <select id="dateRange" onchange="onDateRangeChange()">
                  <option value="year">Last Year</option>
                  <option value="6months">6 Months</option>
                  <option value="3months">3 Months</option>
                  <option value="month">Month</option>
                  <option value="week">Week</option>
                </select>
              </div>

              <div class="control-group">
                <label for="aggregation">View:</label>
                <select id="aggregation" onchange="updateChart()">
                  <option value="daily">Daily</option>
                  <option value="weekly" selected>Weekly</option>
                  <option value="monthly">Monthly</option>
                </select>
              </div>

              <div class="control-group">
                <input
                  type="checkbox"
                  id="cumulative"
                  onchange="updateChart()"
                />
                <label for="cumulative">Cumulative</label>
              </div>
            </div>
          </div>

          <!-- Chart Type Selector -->
          <div class="chart-type-selector">
            <div
              class="chart-type-card"
              data-chart-type="default"
              onclick="selectChartType('default')"
            >
              <i data-lucide="calendar" class="icon"></i>
              <span class="label">Heatmap</span>
            </div>
            <div
              class="chart-type-card active"
              data-chart-type="line"
              onclick="selectChartType('line')"
            >
              <i data-lucide="trending-up" class="icon"></i>
              <span class="label">Line Chart</span>
            </div>
            <div
              class="chart-type-card"
              data-chart-type="bar"
              onclick="selectChartType('bar')"
            >
              <i data-lucide="bar-chart-3" class="icon"></i>
              <span class="label">Bar Chart</span>
            </div>
            <div
              class="chart-type-card"
              data-chart-type="donut"
              onclick="selectChartType('donut')"
            >
              <i data-lucide="pie-chart" class="icon"></i>
              <span class="label">Day Analysis</span>
            </div>
          </div>

          <!-- Hidden input for compatibility -->
          <input type="hidden" id="chartType" value="line" />

          <div
            id="chartContainer"
            class="chart-container"
            style="display: block"
          >
            <div
              id="chartLegend"
              class="chart-legend"
              style="display: none"
            ></div>
            <div id="heatmapChart" class="chart-wrapper"></div>
            <div id="lineChart" class="chart-wrapper" style="display: none">
              <canvas id="lineCanvas"></canvas>
            </div>
            <div id="barChart" class="chart-wrapper" style="display: none">
              <canvas id="barCanvas"></canvas>
            </div>
            <div id="donutChart" class="chart-wrapper" style="display: none">
              <canvas id="donutCanvas"></canvas>
            </div>
          </div>
        </div>

        <!-- Comparison Stats -->
        <div
          id="comparisonStats"
          class="comparison-stats"
          style="display: none; margin-top: 20px"
        >
          <div
            style="
              color: #8b949e;
              margin-bottom: 20px;
              font-size: 0.9rem;
              font-weight: 500;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
          >
            Comparison
          </div>
          <div id="comparisonTable"></div>
        </div>
      </div>
    </div>

    <script>
      let allContributionData = []; // Store all fetched data
      let filteredContributionData = []; // Currently filtered data
      let usersData = new Map(); // Store all users data: username -> {userData, contributions, filteredContributions, dominantColor}
      let currentUser = "";
      let lineChartInstance = null;
      let barChartInstance = null;
      let donutChartInstance = null;
      const MAX_USERS = 5;

      // Function to extract dominant color from user avatar
      async function extractDominantColor(imageUrl) {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";

          img.onload = function () {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            // Resize for faster processing
            const size = 50;
            canvas.width = size;
            canvas.height = size;

            ctx.drawImage(img, 0, 0, size, size);

            try {
              const imageData = ctx.getImageData(0, 0, size, size);
              const data = imageData.data;

              const colorMap = new Map();
              const step = 4; // Sample every 4th pixel for performance

              for (let i = 0; i < data.length; i += 4 * step) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const alpha = data[i + 3];

                // Skip transparent pixels and very light/dark colors
                if (
                  alpha < 128 ||
                  (r > 240 && g > 240 && b > 240) ||
                  (r < 15 && g < 15 && b < 15)
                ) {
                  continue;
                }

                // Group similar colors (reduce precision for better clustering)
                const groupedR = Math.floor(r / 16) * 16;
                const groupedG = Math.floor(g / 16) * 16;
                const groupedB = Math.floor(b / 16) * 16;

                const colorKey = `${groupedR},${groupedG},${groupedB}`;
                colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
              }

              // Find most frequent color
              let dominantColor = "#58a6ff"; // fallback
              let maxCount = 0;

              for (const [colorKey, count] of colorMap.entries()) {
                if (count > maxCount) {
                  maxCount = count;
                  const [r, g, b] = colorKey.split(",").map(Number);
                  // Ensure good contrast and vibrancy
                  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                  if (brightness > 50 && brightness < 200) {
                    dominantColor = `#${r.toString(16).padStart(2, "0")}${g
                      .toString(16)
                      .padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
                  }
                }
              }

              resolve(dominantColor);
            } catch (error) {
              console.warn("Could not extract color from avatar:", error);
              resolve("#58a6ff"); // fallback
            }
          };

          img.onerror = function () {
            console.warn("Could not load avatar image");
            resolve("#58a6ff"); // fallback
          };

          img.src = imageUrl;
        });
      }

      // Function to create or get custom tooltip element
      function getOrCreateTooltip(chart) {
        let tooltipEl =
          chart.canvas.parentNode.querySelector("div.custom-tooltip");

        if (!tooltipEl) {
          tooltipEl = document.createElement("div");
          tooltipEl.classList.add("custom-tooltip");
          tooltipEl.style.background = "#0d1117f2";
          tooltipEl.style.borderRadius = "8px";
          tooltipEl.style.color = "#e6edf3";
          tooltipEl.style.opacity = 0;
          tooltipEl.style.pointerEvents = "none";
          tooltipEl.style.position = "absolute";
          tooltipEl.style.transform = "translate(-50%, 0)";
          tooltipEl.style.transition = "all .1s ease";
          tooltipEl.style.border = "1px solid #30363d";
          tooltipEl.style.boxShadow = "0 4px 12px #00000066";
          tooltipEl.style.zIndex = "1000";

          chart.canvas.parentNode.appendChild(tooltipEl);
        }

        return tooltipEl;
      }

      // Unified tooltip content generator - simple design like line chart
      function generateTooltipContent(dataPoints, title) {
        let innerHtml = '<div style="padding: 8px;">';

        // Title
        if (title) {
          innerHtml +=
            '<div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #f0f6fc; text-align: center;">' +
            title +
            "</div>";
        }

        // Body with avatars - simple design
        dataPoints.forEach(function (point) {
          const username = point.username;
          const userDataEntry = usersData.get(username);
          const avatarUrl = userDataEntry?.userData?.avatar_url || "";
          const color =
            point.color || userDataEntry?.dominantColor || "#58a6ff";
          const contributions = point.contributions;

          innerHtml +=
            '<div style="display: flex; align-items: center; gap: 10px; margin: 6px 0; font-size: 14px; padding: 4px 0;">';
          innerHtml +=
            '<img src="' +
            avatarUrl +
            '" style="width: 24px; height: 24px; border-radius: 50%; border: 2px solid ' +
            color +
            '; object-fit: cover; flex-shrink: 0;">';
          innerHtml += '<div style="flex: 1;">';
          innerHtml +=
            '<div style="color: #f0f6fc; font-weight: 600; font-size: 14px;">' +
            username +
            "</div>";
          innerHtml +=
            '<div style="color: #8b949e; font-size: 13px;">' +
            contributions +
            " contributions</div>";
          innerHtml += "</div>";
          innerHtml += "</div>";
        });

        innerHtml += "</div>";
        return innerHtml;
      }

      // Function to render custom legend with avatars
      function renderCustomLegend(chart) {
        const legendContainer = document.getElementById("chartLegend");
        const datasets = chart.data.datasets;

        if (!datasets || datasets.length === 0) {
          legendContainer.style.display = "none";
          return;
        }

        legendContainer.style.display = "flex";
        legendContainer.style.flexDirection = "row"; // Reset to row for other charts
        legendContainer.style.gap = "20px"; // Reset gap
        legendContainer.innerHTML = "";

        datasets.forEach((dataset, index) => {
          const username = dataset.label;
          const userDataEntry = usersData.get(username);
          const color = dataset.borderColor || dataset.backgroundColor;

          const legendItem = document.createElement("div");
          legendItem.className = "legend-item";
          legendItem.dataset.index = index;

          const avatar = document.createElement("img");
          avatar.className = "legend-avatar";
          avatar.src = userDataEntry?.userData?.avatar_url || "";
          avatar.alt = username;
          avatar.style.borderColor = color;

          const text = document.createElement("span");
          text.className = "legend-text";
          text.textContent = username;

          legendItem.appendChild(avatar);
          legendItem.appendChild(text);

          // Add click handler to toggle dataset visibility
          legendItem.addEventListener("click", () => {
            const meta = chart.getDatasetMeta(index);
            meta.hidden = !meta.hidden;
            legendItem.classList.toggle("hidden", meta.hidden);
            chart.update();
          });

          legendContainer.appendChild(legendItem);
        });
      }

      // Fetch GitHub contributions using the contributions HTML endpoint
      async function fetchContributions() {
        const username = document.getElementById("githubHandle").value.trim();
        if (!username) {
          showError("Please enter a GitHub username");
          return;
        }

        if (usersData.has(username)) {
          showError("User already added");
          return;
        }

        // Set as current user if this is the first user
        if (usersData.size === 0) {
          currentUser = username;
        }
        setButtonLoading(true);
        hideError();

        // Add loading state to welcome screen
        document.getElementById("welcomeScreen").classList.add("loading");

        // Always fetch full year of data
        const { fromDate, toDate } = getFullYearRange();
        let contributionsUrl = `https://github.com/users/${username}/contributions?from=${fromDate}&to=${toDate}`;

        try {
          // First check if user exists
          const userResponse = await fetch(
            `https://api.github.com/users/${username}`
          );
          if (!userResponse.ok) {
            throw new Error("User not found");
          }

          // Use CORS proxy since GitHub doesn't send Access-Control-Allow-Origin
          const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(
            contributionsUrl
          )}`;
          const contributionsResponse = await fetch(proxyUrl);

          if (!contributionsResponse.ok) {
            throw new Error(
              `Failed to fetch contributions data (HTTP ${contributionsResponse.status})`
            );
          }

          const responseHtml = await contributionsResponse.text();
          allContributionData = parseContributionsHtml(responseHtml);

          if (allContributionData.length === 0) {
            throw new Error("No contribution data found");
          }

          // Fetch user profile info
          const userData = await fetchUserProfile(username);

          // Extract dominant color from avatar
          const dominantColor = await extractDominantColor(userData.avatar_url);

          // Store user data
          usersData.set(username, {
            userData: userData,
            contributions: [...allContributionData],
            filteredContributions: [],
            dominantColor: dominantColor,
          });

          // Apply current date range filter
          applyDateRangeFilterForAllUsers();

          // Transition immediately to main app
          document.getElementById("welcomeScreen").classList.remove("loading");
          document.getElementById("welcomeScreen").style.display = "none";
          document.getElementById("mainApp").style.display = "flex";
          document.body.classList.add("app-active");
          document.getElementById("mainApp").classList.add("fade-in");

          // Show user card and metrics
          showUserCard(userData, true);
          updateDisplays();

          // Clear the input field
          document.getElementById("githubHandle").value = "";
        } catch (error) {
          showError(`Error fetching data: ${error.message}`);
          console.error("Full error:", error);
          console.log("Attempted URL:", contributionsUrl);

          // Remove loading state on error
          document.getElementById("welcomeScreen").classList.remove("loading");
        } finally {
          setButtonLoading(false);
        }
      }

      // Fetch user profile information
      async function fetchUserProfile(username) {
        try {
          const response = await fetch(
            `https://api.github.com/users/${username}`
          );
          if (!response.ok) {
            throw new Error("User not found");
          }
          return await response.json();
        } catch (error) {
          console.error("Error fetching user profile:", error);
          return {
            login: username,
            name: username,
            avatar_url: `https://github.com/${username}.png`,
            public_repos: 0,
            followers: 0,
          };
        }
      }

      // Show user card in sidebar
      function showUserCard(userData, isPrimary = false) {
        const usersList = document.getElementById("usersList");
        const cardClass = isPrimary
          ? "user-card primary"
          : "user-card comparison";

        const userCard = document.createElement("div");
        userCard.className = cardClass;
        userCard.id = `user-card-${userData.login}`;

        // Format join date
        const joinDate = new Date(userData.created_at).toLocaleDateString(
          "en-US",
          {
            year: "numeric",
            month: "short",
          }
        );

        // Build bio section
        const bioSection = userData.bio
          ? `<div class="user-bio">${userData.bio}</div>`
          : "";

        // Build location section
        const locationSection = userData.location
          ? `<div class="user-location">
                    <i data-lucide="map-pin" style="width: 12px; height: 12px;"></i>
                    ${userData.location}
                </div>`
          : "";

        // Build company section
        const companySection = userData.company
          ? `<div class="user-location">
                    <i data-lucide="building" style="width: 12px; height: 12px;"></i>
                    ${userData.company}
                </div>`
          : "";

        // Build links section
        let linksSection = "";
        const links = [];

        if (userData.blog) {
          const normalizedUrl = userData.blog.startsWith("http")
            ? userData.blog
            : `https://${userData.blog}`;
          links.push(`<a href="${normalizedUrl}" target="_blank" class="user-link">
                    <i data-lucide="globe" style="width: 12px; height: 12px;"></i>
                    Website
                </a>`);
        }

        if (userData.twitter_username) {
          links.push(`<a href="https://x.com/${userData.twitter_username}" target="_blank" class="user-link">
                    <i data-lucide="twitter" style="width: 12px; height: 12px;"></i>
                    @${userData.twitter_username}
                </a>`);
        }

        if (links.length > 0) {
          linksSection = `<div class="user-links">${links.join("")}</div>`;
        }

        userCard.innerHTML = `
                <div class="user-header">
                    <img src="${userData.avatar_url}" alt="${
          userData.login
        }" class="user-avatar" />
                    <div class="user-info">
                        <a href="${
                          userData.html_url
                        }" target="_blank" class="user-name"><h3>${
          userData.name || userData.login
        }</h3></a>
                        <div class="username">@${userData.login}</div>
                    </div>
                </div>

                ${bioSection}
                ${locationSection}
                ${companySection}
                
                <div class="user-stats">
                    <div class="user-stat">
                        <i data-lucide="git-branch" style="width: 12px; height: 12px;"></i>
                        <span class="user-stat-value">${
                          userData.public_repos || 0
                        }</span>
                        <span>repos</span>
                    </div>
                    ${
                      userData.public_gists > 0
                        ? `<div class="user-stat">
                        <i data-lucide="file-text" style="width: 12px; height: 12px;"></i>
                        <span class="user-stat-value">${
                          userData.public_gists || 0
                        }</span>
                        <span>gists</span>
                    </div>`
                        : ""
                    }
                    <div class="user-stat">
                        <i data-lucide="users" style="width: 12px; height: 12px;"></i>
                        <span class="user-stat-value">${
                          userData.followers || 0
                        }</span>
                        <span>followers</span>
                    </div>
                    <div class="user-stat">
                        <i data-lucide="user-check" style="width: 12px; height: 12px;"></i>
                        <span class="user-stat-value">${
                          userData.following || 0
                        }</span>
                        <span>following</span>
                    </div>
                </div>
                
                ${linksSection}
                
                <div class="user-join-date">
                    <i data-lucide="calendar" style="width: 10px; height: 10px; margin-right: 4px;"></i>
                    Joined ${joinDate}
                </div>
            `;

        if (isPrimary) {
          usersList.insertBefore(userCard, usersList.firstChild);
        } else {
          usersList.appendChild(userCard);
        }

        // Initialize Lucide icons
        lucide.createIcons();
      }

      // Toggle add user input
      function toggleAddUser() {
        const addUserInput = document.getElementById("addUserInput");
        const isVisible = addUserInput.style.display === "flex";

        addUserInput.style.display = isVisible ? "none" : "flex";

        if (!isVisible) {
          document.getElementById("compareHandle").focus();
        } else {
          document.getElementById("compareHandle").value = "";
        }
      }

      // Fetch comparison user data
      async function fetchComparisonData() {
        const username = document.getElementById("compareHandle").value.trim();
        if (!username) {
          showError("Please enter a username to compare with");
          return;
        }

        if (usersData.has(username)) {
          showError("User already added");
          return;
        }

        if (usersData.size >= MAX_USERS) {
          showError(`Maximum ${MAX_USERS} users allowed`);
          return;
        }

        showLoading(true);
        hideError();

        const { fromDate, toDate } = getFullYearRange();
        let contributionsUrl = `https://github.com/users/${username}/contributions?from=${fromDate}&to=${toDate}`;

        try {
          // Check if user exists
          const userResponse = await fetch(
            `https://api.github.com/users/${username}`
          );
          if (!userResponse.ok) {
            throw new Error("User not found");
          }

          // Fetch contributions
          const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(
            contributionsUrl
          )}`;
          const contributionsResponse = await fetch(proxyUrl);

          if (!contributionsResponse.ok) {
            throw new Error(
              `Failed to fetch user data (HTTP ${contributionsResponse.status})`
            );
          }

          const responseHtml = await contributionsResponse.text();
          const contributionsData = parseContributionsHtml(responseHtml);

          if (contributionsData.length === 0) {
            throw new Error("No contribution data found");
          }

          // Fetch user profile and show card
          const userData = await fetchUserProfile(username);

          // Extract dominant color from avatar
          const dominantColor = await extractDominantColor(userData.avatar_url);

          // Store user data
          usersData.set(username, {
            userData: userData,
            contributions: [...contributionsData],
            filteredContributions: [],
            dominantColor: dominantColor,
          });

          // Apply current date range filter to all users
          applyDateRangeFilterForAllUsers();

          showUserCard(userData, false);

          // Hide add user input
          toggleAddUser();

          // Update displays
          updateDisplays();

          // Clear the comparison input field
          document.getElementById("compareHandle").value = "";
        } catch (error) {
          showError(`Error fetching user data: ${error.message}`);
          console.error("Fetch error:", error);
        } finally {
          showLoading(false);
        }
      }

      // Add new helper functions for multi-user management
      function applyDateRangeFilterForAllUsers() {
        const dateRange = document.getElementById("dateRange").value;
        const { fromDate, toDate } = getDateRange(dateRange);

        for (const [username, userData] of usersData) {
          userData.filteredContributions = userData.contributions.filter(
            (item) => {
              const itemDate = new Date(item.date);
              return (
                itemDate >= new Date(fromDate) && itemDate <= new Date(toDate)
              );
            }
          );
        }

        // Set primary user's filtered data for backward compatibility
        if (currentUser && usersData.has(currentUser)) {
          filteredContributionData =
            usersData.get(currentUser).filteredContributions;
        }
      }

      function updateDisplays() {
        if (currentUser && usersData.has(currentUser)) {
          showMetrics(usersData.get(currentUser).filteredContributions);
        }

        if (usersData.size > 1) {
          showComparisonStats();
        }

        updateChart();
      }

      function getFullYearRange() {
        const now = new Date();
        const fromDate = new Date(now.getFullYear(), 0, 1);
        const toDate = new Date(now.getFullYear(), 11, 31);

        return {
          fromDate: fromDate.toISOString().split("T")[0],
          toDate: toDate.toISOString().split("T")[0],
        };
      }

      function getDateRange(range) {
        const now = new Date();
        let fromDate, toDate;

        switch (range) {
          case "week":
            fromDate = new Date(
              now.getFullYear(),
              now.getMonth(),
              now.getDate() - 6
            );
            toDate = new Date(now);
            break;
          case "month":
            fromDate = new Date(
              now.getFullYear(),
              now.getMonth() - 1,
              now.getDate()
            );
            toDate = new Date(now);
            break;
          case "3months":
            fromDate = new Date(
              now.getFullYear(),
              now.getMonth() - 3,
              now.getDate()
            );
            toDate = new Date(now);
            break;
          case "6months":
            fromDate = new Date(
              now.getFullYear(),
              now.getMonth() - 6,
              now.getDate()
            );
            toDate = new Date(now);
            break;
          case "year":
          default:
            fromDate = new Date(now.getFullYear(), 0, 1);
            toDate = new Date(now.getFullYear(), 11, 31);
            break;
        }

        return {
          fromDate: fromDate.toISOString().split("T")[0],
          toDate: toDate.toISOString().split("T")[0],
        };
      }

      // Legacy functions removed - now handled by applyDateRangeFilterForAllUsers

      function aggregateData(data, aggregationType) {
        if (aggregationType === "daily") {
          return data;
        }

        const aggregated = {};

        data.forEach((item) => {
          const date = new Date(item.date);
          let key, displayDate;

          if (aggregationType === "weekly") {
            // Get Monday of the week
            const monday = new Date(date);
            monday.setDate(
              date.getDate() - date.getDay() + (date.getDay() === 0 ? -6 : 1)
            );
            key = monday.toISOString().split("T")[0];
            displayDate = `Week of ${monday.toLocaleDateString()}`;
          } else if (aggregationType === "monthly") {
            key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(
              2,
              "0"
            )}`;
            displayDate = date.toLocaleDateString("en-US", {
              year: "numeric",
              month: "long",
            });
          }

          if (!aggregated[key]) {
            aggregated[key] = {
              date: displayDate || key,
              contributions: 0,
              count: 0,
            };
          }

          aggregated[key].contributions += item.contributions;
          aggregated[key].count += 1;
        });

        return Object.values(aggregated).sort((a, b) => {
          // For monthly data, sort by the key (YYYY-MM format)
          if (aggregationType === "monthly") {
            return (
              Object.keys(aggregated).indexOf(a.date) -
              Object.keys(aggregated).indexOf(b.date)
            );
          }
          return new Date(a.date) - new Date(b.date);
        });
      }

      function parseContributionsHtml(html) {
        // Create a temporary DOM to parse the HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");

        // Find all contribution day elements
        const contributionDays = doc.querySelectorAll(
          "td.ContributionCalendar-day"
        );
        const data = [];

        contributionDays.forEach((day) => {
          const date = day.getAttribute("data-date");
          const level = parseInt(day.getAttribute("data-level") || "0", 10);

          // Find the associated tooltip to get the actual contribution count
          const dayId = day.getAttribute("id");
          let contributions = 0;

          if (dayId) {
            const tooltip = doc.querySelector(`tool-tip[for="${dayId}"]`);
            if (tooltip) {
              const tooltipText = tooltip.textContent || "";
              contributions = parseContributionCount(tooltipText);
            }
          }

          // If we couldn't get exact count from tooltip, estimate from level
          if (contributions === 0 && level > 0) {
            contributions = estimateContributionsFromLevel(level);
          }

          if (date) {
            data.push({
              date: date,
              contributions: contributions,
              level: level,
            });
          }
        });

        // Sort by date
        return data.sort((a, b) => new Date(a.date) - new Date(b.date));
      }

      function parseContributionCount(tooltipText) {
        // Parse text like "6 contributions on January 7th." or "1 contribution on January 21st."
        const match = tooltipText.match(/(\d+)\s+contributions?/);
        if (match) {
          return parseInt(match[1], 10);
        }

        // Handle "No contributions" case
        if (tooltipText.includes("No contributions")) {
          return 0;
        }

        return 0;
      }

      function estimateContributionsFromLevel(level) {
        // GitHub uses levels 0-4, estimate contribution counts
        const estimates = [0, 1, 3, 6, 10];
        return estimates[level] || 0;
      }

      function onDateRangeChange() {
        // Filter existing data for all users instead of re-fetching
        if (usersData.size > 0) {
          applyDateRangeFilterForAllUsers();
          updateDisplays();
        }
      }

      function makeCumulative(data) {
        let cumsum = 0;
        return data.map((item) => ({
          ...item,
          contributions: (cumsum += item.contributions),
        }));
      }

      // Global variable to track current chart type
      let currentChartType = "line";

      function selectChartType(chartType) {
        // Update active state
        document.querySelectorAll(".chart-type-card").forEach((card) => {
          card.classList.remove("active");
        });
        document
          .querySelector(`[data-chart-type="${chartType}"]`)
          .classList.add("active");

        // Update current chart type and hidden input for compatibility
        currentChartType = chartType;
        document.getElementById("chartType").value = chartType;

        // Auto-switch to daily view for heatmap
        if (chartType === "default") {
          document.getElementById("aggregation").value = "daily";
          applyDateRangeFilterForAllUsers();
        }

        // Update chart
        updateChart();

        // Initialize icons
        lucide.createIcons();
      }

      function updateChart() {
        if (usersData.size === 0 || !currentUser || !usersData.has(currentUser))
          return;

        const chartType = currentChartType;
        const isCumulative = document.getElementById("cumulative").checked;
        const aggregationType = document.getElementById("aggregation").value;

        // Use current user's data for the primary display
        let processedData = aggregateData(
          [...usersData.get(currentUser).filteredContributions],
          aggregationType
        );

        if (isCumulative) {
          processedData = makeCumulative(processedData);
        }

        // Hide all chart types
        document.getElementById("heatmapChart").style.display = "none";
        document.getElementById("lineChart").style.display = "none";
        document.getElementById("barChart").style.display = "none";
        document.getElementById("donutChart").style.display = "none";

        switch (chartType) {
          case "line":
            showLineChart(processedData);
            break;
          case "bar":
            showBarChart(processedData);
            break;
          case "donut":
            showDonutChart(processedData);
            break;
          default:
            showHeatmapChart(processedData);
        }
      }

      // Track hidden users for heatmap
      let hiddenHeatmapUsers = new Set();

      function showHeatmapChart(data) {
        const container = document.getElementById("heatmapChart");
        container.style.display = "block";

        // Show custom legend for heatmap when multiple users
        const legendContainer = document.getElementById("chartLegend");
        if (usersData.size > 1) {
          renderHeatmapLegend();
          legendContainer.style.display = "flex";
        } else {
          legendContainer.style.display = "none";
        }

        // Only show heatmap for daily data
        const aggregationType = document.getElementById("aggregation").value;
        if (aggregationType !== "daily") {
          container.innerHTML =
            '<p style="text-align: center; color: #8b949e; padding: 40px;">Heatmap view is only available for daily data. Please select "Daily" view.</p>';
          return;
        }

        container.innerHTML = "";
        container.style.height = "auto"; // Allow container to grow
        container.style.overflow = "visible"; // No scrolling

        // Create heatmaps for each user
        const cellSize = 16; // Bigger cells
        const gap = 3; // Bigger gaps

        // Create shared tooltip for better positioning
        let sharedTooltip = document.getElementById("shared-heatmap-tooltip");
        if (!sharedTooltip) {
          sharedTooltip = document.createElement("div");
          sharedTooltip.id = "shared-heatmap-tooltip";
          sharedTooltip.style.background = "#0d1117f2";
          sharedTooltip.style.borderRadius = "8px";
          sharedTooltip.style.color = "#e6edf3";
          sharedTooltip.style.opacity = "0";
          sharedTooltip.style.pointerEvents = "none";
          sharedTooltip.style.position = "fixed"; // Use fixed positioning
          sharedTooltip.style.padding = "8px";
          sharedTooltip.style.fontSize = "13px";
          sharedTooltip.style.zIndex = "1000";
          sharedTooltip.style.border = "1px solid #30363d";
          sharedTooltip.style.boxShadow = "0 4px 12px #00000066";
          sharedTooltip.style.transition = "opacity 0.2s ease";
          sharedTooltip.style.transform = "translate(-50%, -100%)";

          document.body.appendChild(sharedTooltip);
        }

        for (const [username, userData] of usersData) {
          // Skip hidden users
          if (hiddenHeatmapUsers.has(username)) {
            continue;
          }

          const userContainer = document.createElement("div");
          userContainer.style.marginBottom = "30px";
          userContainer.style.position = "relative";

          // User label
          const userLabel = document.createElement("div");
          userLabel.style.color = "#f0f6fc";
          userLabel.style.fontSize = "16px";
          userLabel.style.fontWeight = "600";
          userLabel.style.marginBottom = "16px";
          userLabel.style.display = "flex";
          userLabel.style.alignItems = "center";
          userLabel.style.gap = "10px";

          const avatar = document.createElement("img");
          avatar.src = userData.userData.avatar_url;
          avatar.style.width = "24px";
          avatar.style.height = "24px";
          avatar.style.borderRadius = "50%";
          avatar.style.border = `2px solid ${userData.dominantColor}`;
          avatar.style.objectFit = "cover";

          userLabel.appendChild(avatar);
          userLabel.appendChild(document.createTextNode(username));
          userContainer.appendChild(userLabel);

          // Process user's filtered data
          const userFilteredData = userData.filteredContributions;

          if (userFilteredData.length === 0) {
            const noDataMsg = document.createElement("div");
            noDataMsg.style.color = "#8b949e";
            noDataMsg.style.fontStyle = "italic";
            noDataMsg.style.padding = "20px 0";
            noDataMsg.textContent = "No data for selected period";
            userContainer.appendChild(noDataMsg);
            container.appendChild(userContainer);
            continue;
          }

          const maxContributions = Math.max(
            ...userFilteredData.map((d) => d.contributions)
          );

          // Create container for labels and chart
          const chartContainer = document.createElement("div");
          chartContainer.style.position = "relative";

          // Calculate weeks needed and adjust for starting on Sunday
          // Parse dates as local dates to avoid timezone issues
          const firstDate = new Date(userFilteredData[0].date + "T00:00:00");
          const lastDate = new Date(
            userFilteredData[userFilteredData.length - 1].date + "T00:00:00"
          );

          // Find the Sunday before or on the first date
          const startDate = new Date(firstDate);
          startDate.setDate(firstDate.getDate() - firstDate.getDay()); // Move to Sunday

          // Find the Saturday after or on the last date
          const endDate = new Date(lastDate);
          endDate.setDate(lastDate.getDate() + (6 - lastDate.getDay())); // Move to Saturday

          // Calculate total weeks
          const totalDays =
            Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000)) + 1;
          const totalWeeks = Math.ceil(totalDays / 7);

          // Create data map for quick lookup
          const dataMap = new Map();
          userFilteredData.forEach((item) => {
            dataMap.set(item.date, item.contributions);
          });

          // Add margins for labels
          const labelMarginTop = 25;
          const labelMarginLeft = 30;
          const svgWidth = totalWeeks * (cellSize + gap) + labelMarginLeft;
          const svgHeight = 7 * (cellSize + gap) + labelMarginTop;

          // Create SVG for this user - bigger with margins for labels
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );
          svg.style.width = "100%";
          svg.style.height = "180px"; // Increased height for labels
          svg.style.minHeight = "180px";
          svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
          svg.setAttribute("preserveAspectRatio", "xMinYMin meet");

          // Add month labels
          let currentMonth = -1;
          for (let week = 0; week < totalWeeks; week++) {
            const weekDate = new Date(startDate);
            weekDate.setDate(startDate.getDate() + week * 7);
            const month = weekDate.getMonth();
            const monthName = weekDate.toLocaleDateString("en-US", {
              month: "short",
            });

            // Show first month and when month changes
            if (month !== currentMonth) {
              const text = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              text.setAttribute("x", labelMarginLeft + week * (cellSize + gap));
              text.setAttribute("y", 15);
              text.setAttribute("font-size", "11px");
              text.setAttribute(
                "font-family",
                "system-ui, -apple-system, sans-serif"
              );
              text.setAttribute("fill", "#8b949e");
              text.textContent = monthName;
              svg.appendChild(text);
              currentMonth = month;
            }
          }

          // Add day labels (Mon, Wed, Fri pattern like GitHub)
          const dayLabels = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
          [1, 3, 5].forEach((dayIndex) => {
            // Show Mon, Wed, Fri
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", 5);
            text.setAttribute(
              "y",
              labelMarginTop + dayIndex * (cellSize + gap) + cellSize / 2 + 3
            );
            text.setAttribute("font-size", "9px");
            text.setAttribute(
              "font-family",
              "system-ui, -apple-system, sans-serif"
            );
            text.setAttribute("fill", "#8b949e");
            text.setAttribute("text-anchor", "start");
            text.textContent = dayLabels[dayIndex];
            svg.appendChild(text);
          });

          // Generate grid
          for (let week = 0; week < totalWeeks; week++) {
            for (let day = 0; day < 7; day++) {
              const currentDate = new Date(startDate);
              currentDate.setDate(startDate.getDate() + week * 7 + day);
              // Use local date string to match our data format
              const year = currentDate.getFullYear();
              const month = String(currentDate.getMonth() + 1).padStart(2, "0");
              const dayOfMonth = String(currentDate.getDate()).padStart(2, "0");
              const dateStr = `${year}-${month}-${dayOfMonth}`;

              // Always render the cell for proper grid alignment
              // Check if this date has contribution data
              const contributions = dataMap.get(dateStr) || 0;
              const intensity =
                maxContributions > 0 ? contributions / maxContributions : 0;

              // Only show empty cells for dates within a reasonable range
              const isWithinDataPeriod =
                currentDate >= firstDate && currentDate <= lastDate;

              const rect = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
              );
              rect.setAttribute("x", labelMarginLeft + week * (cellSize + gap));
              rect.setAttribute("y", labelMarginTop + day * (cellSize + gap));
              rect.setAttribute("width", cellSize);
              rect.setAttribute("height", cellSize);
              rect.setAttribute("rx", 3);

              // Use exact same color scheme as line/bar charts
              const baseColor = userData.dominantColor || "#58a6ff";
              let color;
              let stroke = "#1b1f23";

              // Show different colors for dates outside data period vs no contributions
              if (!isWithinDataPeriod) {
                color = "transparent"; // Very dark for dates outside data period
                stroke = "transparent";
              } else if (intensity === 0) {
                color = "#161b22"; // Empty state for dates with no contributions
              } else {
                // Create solid colors with varying opacity based on intensity
                const rgb = hexToRgb(baseColor) || { r: 88, g: 166, b: 255 };
                // Use different intensities: 0.3, 0.5, 0.7, 1.0
                let alpha;
                if (intensity <= 0.25) alpha = "4d"; // 30% opacity
                else if (intensity <= 0.5) alpha = "80"; // 50% opacity
                else if (intensity <= 0.75) alpha = "b3"; // 70% opacity
                else alpha = "ff"; // 100% opacity

                color = `#${rgb.r.toString(16).padStart(2, "0")}${rgb.g
                  .toString(16)
                  .padStart(2, "0")}${rgb.b
                  .toString(16)
                  .padStart(2, "0")}${alpha}`;
              }

              rect.setAttribute("fill", color);
              rect.setAttribute("stroke", stroke);
              rect.setAttribute("stroke-width", "1");

              // Only add interactivity for dates within the data period
              if (isWithinDataPeriod) {
                rect.style.cursor = "pointer";

                // Add hover events for tooltip
                rect.addEventListener("mouseenter", function (e) {
                  const formattedDate = currentDate.toLocaleDateString(
                    "en-US",
                    {
                      weekday: "short",
                      month: "short",
                      day: "numeric",
                      year: "numeric",
                    }
                  );

                  // Use unified tooltip function
                  const tooltipContent = generateTooltipContent(
                    [
                      {
                        username: username,
                        contributions: contributions,
                        color: baseColor,
                      },
                    ],
                    formattedDate
                  );

                  sharedTooltip.innerHTML = tooltipContent;

                  // Position tooltip at mouse cursor
                  sharedTooltip.style.left = e.clientX + "px";
                  sharedTooltip.style.top = e.clientY + "px";
                  sharedTooltip.style.opacity = "1";
                });

                rect.addEventListener("mouseleave", function () {
                  sharedTooltip.style.opacity = "0";
                });

                rect.addEventListener("mousemove", function (e) {
                  sharedTooltip.style.left = e.clientX + "px";
                  sharedTooltip.style.top = e.clientY + "px";
                });
              }

              svg.appendChild(rect);
            }
          }

          userContainer.appendChild(svg);
          container.appendChild(userContainer);
        }

        // Add contribution intensity legend after all users
        addContributionIntensityLegend(container);
      }

      // Function to add GitHub-style contribution intensity legend
      function addContributionIntensityLegend(container) {
        // For multiple users, show a generic legend
        const visibleUsers = Array.from(usersData.entries()).filter(
          ([username]) => !hiddenHeatmapUsers.has(username)
        );

        if (visibleUsers.length === 0) return;

        const legendContainer = document.createElement("div");
        legendContainer.style.display = "flex";
        legendContainer.style.alignItems = "center";
        legendContainer.style.justifyContent = "flex-end";
        legendContainer.style.gap = "4px";
        legendContainer.style.marginTop = "20px";
        legendContainer.style.fontSize = "11px";
        legendContainer.style.color = "#8b949e";
        legendContainer.style.fontFamily =
          "system-ui, -apple-system, sans-serif";

        // "Less" text
        const lessText = document.createElement("span");
        lessText.textContent = "Less";
        lessText.style.marginRight = "4px";
        legendContainer.appendChild(lessText);

        // Use the first visible user's color for the legend
        const firstUser = visibleUsers[0][1];
        const baseColor = firstUser.dominantColor || "#58a6ff";
        const rgb = hexToRgb(baseColor) || { r: 88, g: 166, b: 255 };

        // Create intensity squares using the user's color
        const intensities = ["00", "4d", "80", "b3", "ff"]; // 0%, 30%, 50%, 70%, 100%
        intensities.forEach((alpha, index) => {
          const square = document.createElement("div");
          square.style.width = "10px";
          square.style.height = "10px";

          if (index === 0) {
            square.style.backgroundColor = "#161b22"; // Empty state
          } else {
            const color = `#${rgb.r.toString(16).padStart(2, "0")}${rgb.g
              .toString(16)
              .padStart(2, "0")}${rgb.b.toString(16).padStart(2, "0")}${alpha}`;
            square.style.backgroundColor = color;
          }

          square.style.border = "1px solid #1b1f23";
          square.style.borderRadius = "2px";
          legendContainer.appendChild(square);
        });

        // "More" text
        const moreText = document.createElement("span");
        moreText.textContent = "More";
        moreText.style.marginLeft = "4px";
        legendContainer.appendChild(moreText);

        container.appendChild(legendContainer);
      }

      // Helper function to convert hex color to RGB
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16),
            }
          : null;
      }

      // Helper function to calculate streaks
      function calculateStreaks(data) {
        const sortedData = [...data].sort(
          (a, b) => new Date(a.date) - new Date(b.date)
        );
        let currentStreak = 0;
        let maxStreak = 0;
        let tempStreak = 0;

        // Calculate from most recent backwards for current streak
        for (let i = sortedData.length - 1; i >= 0; i--) {
          if (sortedData[i].contributions > 0) {
            if (i === sortedData.length - 1 || currentStreak > 0) {
              currentStreak++;
            } else {
              break; // Current streak broken
            }
          } else {
            if (i === sortedData.length - 1) {
              currentStreak = 0;
            }
            break;
          }
        }

        // Calculate max streak
        for (let i = 0; i < sortedData.length; i++) {
          if (sortedData[i].contributions > 0) {
            tempStreak++;
            maxStreak = Math.max(maxStreak, tempStreak);
          } else {
            tempStreak = 0;
          }
        }

        return { currentStreak, maxStreak };
      }

      // Function to render heatmap legend
      function renderHeatmapLegend() {
        const legendContainer = document.getElementById("chartLegend");
        legendContainer.style.flexDirection = "row"; // Reset to row
        legendContainer.style.gap = "20px"; // Reset gap
        legendContainer.innerHTML = "";

        for (const [username, userData] of usersData) {
          const legendItem = document.createElement("div");
          legendItem.className = "legend-item";
          legendItem.dataset.username = username;

          // Apply hidden state if user is hidden
          if (hiddenHeatmapUsers.has(username)) {
            legendItem.classList.add("hidden");
          }

          const avatar = document.createElement("img");
          avatar.className = "legend-avatar";
          avatar.src = userData.userData.avatar_url;
          avatar.alt = username;
          avatar.style.borderColor = userData.dominantColor;

          const text = document.createElement("span");
          text.className = "legend-text";
          text.textContent = username;

          legendItem.appendChild(avatar);
          legendItem.appendChild(text);

          // Add click handler to toggle user visibility
          legendItem.addEventListener("click", () => {
            if (hiddenHeatmapUsers.has(username)) {
              hiddenHeatmapUsers.delete(username);
              legendItem.classList.remove("hidden");
            } else {
              hiddenHeatmapUsers.add(username);
              legendItem.classList.add("hidden");
            }
            // Re-render the heatmap
            updateChart();
          });

          legendContainer.appendChild(legendItem);
        }
      }

      function showLineChart(data) {
        const container = document.getElementById("lineChart");
        container.style.display = "block";

        if (lineChartInstance) {
          lineChartInstance.destroy();
        }

        const ctx = document.getElementById("lineCanvas").getContext("2d");

        // Prepare datasets for all users
        const datasets = [];
        const fallbackColors = [
          "#58a6ff",
          "#f78166",
          "#39d353",
          "#d2a8ff",
          "#ffdf5d",
        ];
        let colorIndex = 0;

        for (const [username, userData] of usersData) {
          const aggregationType = document.getElementById("aggregation").value;
          let processedData = aggregateData(
            [...userData.filteredContributions],
            aggregationType
          );
          const isCumulative = document.getElementById("cumulative").checked;

          if (isCumulative) {
            processedData = makeCumulative(processedData);
          }

          // Use extracted color or fallback
          const color =
            userData.dominantColor ||
            fallbackColors[colorIndex % fallbackColors.length];

          datasets.push({
            label: username,
            data: processedData.map((d) => d.contributions),
            borderColor: color,
            backgroundColor: `${color}1a`, // Add transparency
            borderWidth: 2,
            fill: false, // No fill for clean line chart
            tension: 0.4,
          });

          colorIndex++;
        }

        lineChartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels: data.map((d) => d.date),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            plugins: {
              legend: {
                display: false, // Hide default legend
              },
              tooltip: {
                enabled: false, // Completely disable default tooltip
                external: function (context) {
                  // Custom tooltip with avatars
                  const tooltip = context.tooltip;
                  const tooltipEl = getOrCreateTooltip(context.chart);

                  // Hide if no tooltip
                  if (tooltip.opacity === 0) {
                    tooltipEl.style.opacity = 0;
                    return;
                  }

                  function getBody(bodyItem) {
                    return bodyItem.lines;
                  }

                  // Set Text
                  if (tooltip.body) {
                    const titleLines = tooltip.title || [];
                    const bodyLines = tooltip.body.map(getBody);

                    let innerHtml = '<div style="padding: 8px;">';

                    // Title
                    titleLines.forEach(function (title) {
                      innerHtml +=
                        '<div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #f0f6fc; text-align: center;">' +
                        title +
                        "</div>";
                    });

                    // Use unified tooltip function
                    const dataPoints = tooltip.dataPoints.map(function (
                      dataPoint
                    ) {
                      return {
                        username: dataPoint.dataset.label,
                        contributions: dataPoint.parsed.y,
                        color: dataPoint.dataset.borderColor,
                      };
                    });

                    tooltipEl.innerHTML = generateTooltipContent(
                      dataPoints,
                      titleLines[0]
                    );
                  }

                  const { offsetLeft: positionX, offsetTop: positionY } =
                    context.chart.canvas;

                  // Display, position, and set styles - positioned relative to canvas
                  tooltipEl.style.opacity = 1;
                  tooltipEl.style.position = "absolute";
                  tooltipEl.style.left = positionX + tooltip.caretX + "px";
                  tooltipEl.style.top = positionY + tooltip.caretY + "px";
                  tooltipEl.style.transform = "translate(-50%, -100%)";
                },
              },
              zoom: {
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  mode: "x",
                },
                pan: {
                  enabled: true,
                  mode: "x",
                },
              },
            },
            scales: {
              x: {
                ticks: {
                  color: "#8b949e",
                  maxTicksLimit: 10,
                },
                grid: {
                  color: "#30363d",
                },
              },
              y: {
                ticks: {
                  color: "#8b949e",
                },
                grid: {
                  color: "#30363d",
                },
              },
            },
          },
        });

        // Render custom legend with avatars
        renderCustomLegend(lineChartInstance);
      }

      function showBarChart(data) {
        const container = document.getElementById("barChart");
        container.style.display = "block";

        if (barChartInstance) {
          barChartInstance.destroy();
        }

        const ctx = document.getElementById("barCanvas").getContext("2d");

        // Prepare datasets for all users
        const datasets = [];
        const fallbackColors = [
          "#58a6ff",
          "#f78166",
          "#39d353",
          "#d2a8ff",
          "#ffdf5d",
        ];
        let colorIndex = 0;

        for (const [username, userData] of usersData) {
          const aggregationType = document.getElementById("aggregation").value;
          let processedData = aggregateData(
            [...userData.filteredContributions],
            aggregationType
          );
          const isCumulative = document.getElementById("cumulative").checked;

          if (isCumulative) {
            processedData = makeCumulative(processedData);
          }

          // Use extracted color or fallback
          const color =
            userData.dominantColor ||
            fallbackColors[colorIndex % fallbackColors.length];

          datasets.push({
            label: username,
            data: processedData.map((d) => d.contributions),
            backgroundColor: color,
            borderColor: color,
            borderWidth: 1,
          });

          colorIndex++;
        }

        barChartInstance = new Chart(ctx, {
          type: "bar",
          data: {
            labels: data.map((d) => d.date),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            plugins: {
              legend: {
                display: false, // Hide default legend
              },
              tooltip: {
                enabled: false, // Completely disable default tooltip
                external: function (context) {
                  // Custom tooltip with avatars
                  const tooltip = context.tooltip;
                  const tooltipEl = getOrCreateTooltip(context.chart);

                  // Hide if no tooltip
                  if (tooltip.opacity === 0) {
                    tooltipEl.style.opacity = 0;
                    return;
                  }

                  function getBody(bodyItem) {
                    return bodyItem.lines;
                  }

                  // Set Text
                  if (tooltip.body) {
                    const titleLines = tooltip.title || [];
                    const bodyLines = tooltip.body.map(getBody);

                    let innerHtml = '<div style="padding: 8px;">';

                    // Title
                    titleLines.forEach(function (title) {
                      innerHtml +=
                        '<div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #f0f6fc; text-align: center;">' +
                        title +
                        "</div>";
                    });

                    // Use unified tooltip function
                    const dataPoints = tooltip.dataPoints.map(function (
                      dataPoint
                    ) {
                      return {
                        username: dataPoint.dataset.label,
                        contributions: dataPoint.parsed.y,
                        color: dataPoint.dataset.borderColor,
                      };
                    });

                    tooltipEl.innerHTML = generateTooltipContent(
                      dataPoints,
                      titleLines[0]
                    );
                  }

                  const { offsetLeft: positionX, offsetTop: positionY } =
                    context.chart.canvas;

                  // Display, position, and set styles - positioned relative to canvas
                  tooltipEl.style.opacity = 1;
                  tooltipEl.style.position = "absolute";
                  tooltipEl.style.left = positionX + tooltip.caretX + "px";
                  tooltipEl.style.top = positionY + tooltip.caretY + "px";
                  tooltipEl.style.transform = "translate(-50%, -100%)";
                },
              },
              zoom: {
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  mode: "x",
                },
                pan: {
                  enabled: true,
                  mode: "x",
                },
              },
            },
            scales: {
              x: {
                ticks: {
                  color: "#8b949e",
                  maxTicksLimit: 10,
                },
                grid: {
                  color: "#30363d",
                },
              },
              y: {
                ticks: {
                  color: "#8b949e",
                },
                grid: {
                  color: "#30363d",
                },
              },
            },
          },
        });

        // Render custom legend with avatars
        renderCustomLegend(barChartInstance);
      }

      // Track hidden days for donut charts
      let hiddenDays = new Set();
      let donutChartInstances = [];

      function showDonutChart(data) {
        const container = document.getElementById("donutChart");
        container.style.display = "block";

        // Clear any existing chart instances
        donutChartInstances.forEach((instance) => {
          if (instance) instance.destroy();
        });
        donutChartInstances = [];

        // Show global toggleable legend
        renderGlobalDonutLegend();
        document.getElementById("chartLegend").style.display = "flex";

        container.innerHTML = "";
        container.style.height = "auto";
        container.style.overflow = "visible";

        // Create grid container
        const gridContainer = document.createElement("div");
        gridContainer.style.display = "grid";
        gridContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
        gridContainer.style.gap = "24px";
        gridContainer.style.maxWidth = "1200px";
        gridContainer.style.margin = "0 auto";
        gridContainer.style.padding = "20px";

        // Responsive adjustments
        const mobileQuery = window.matchMedia("(max-width: 768px)");
        const tabletQuery = window.matchMedia("(max-width: 1024px)");

        if (mobileQuery.matches) {
          gridContainer.style.gridTemplateColumns = "1fr";
          gridContainer.style.gap = "20px";
          gridContainer.style.padding = "16px";
        } else if (tabletQuery.matches) {
          gridContainer.style.gridTemplateColumns = "repeat(2, 1fr)";
          gridContainer.style.gap = "20px";
        }

        container.appendChild(gridContainer);

        const dayNames = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];

        // Create individual donut charts for each user
        for (const [username, userData] of usersData) {
          const userContainer = document.createElement("div");
          userContainer.style.position = "relative";
          userContainer.style.background = "#161b224d";
          userContainer.style.borderRadius = "16px";
          userContainer.style.padding = "20px";
          userContainer.style.backdropFilter = "blur(10px)";

          // User label above chart
          const userLabel = document.createElement("div");
          userLabel.style.color = "#f0f6fc";
          userLabel.style.fontSize = "16px";
          userLabel.style.fontWeight = "600";
          userLabel.style.marginBottom = "16px";
          userLabel.style.textAlign = "center";
          userLabel.style.display = "flex";
          userLabel.style.alignItems = "center";
          userLabel.style.justifyContent = "center";
          userLabel.style.gap = "10px";

          const smallAvatar = document.createElement("img");
          smallAvatar.src = userData.userData.avatar_url;
          smallAvatar.style.width = "40px";
          smallAvatar.style.height = "40px";
          smallAvatar.style.borderRadius = "50%";
          smallAvatar.style.border = `2px solid ${userData.dominantColor}`;
          smallAvatar.style.objectFit = "cover";

          userLabel.appendChild(smallAvatar);
          userLabel.appendChild(document.createTextNode(username));
          userContainer.appendChild(userLabel);

          // Calculate day-of-week statistics for this user
          const dayStats = dayNames.reduce(
            (acc, day) => ({ ...acc, [day]: 0 }),
            {}
          );

          userData.filteredContributions.forEach((item) => {
            const date = new Date(item.date);
            const dayName = date.toLocaleDateString("en-US", {
              weekday: "long",
            });
            dayStats[dayName] += item.contributions;
          });

          // Filter out hidden days
          const visibleDayNames = dayNames.filter(
            (day) => !hiddenDays.has(day)
          );
          const visibleDayValues = visibleDayNames.map((day) => dayStats[day]);
          const totalContributions = visibleDayValues.reduce(
            (sum, val) => sum + val,
            0
          );

          if (totalContributions === 0) {
            const noDataMsg = document.createElement("div");
            noDataMsg.style.color = "#8b949e";
            noDataMsg.style.fontStyle = "italic";
            noDataMsg.style.padding = "40px 20px";
            noDataMsg.style.textAlign = "center";
            noDataMsg.textContent = "No data for selected period";
            userContainer.appendChild(noDataMsg);
            gridContainer.appendChild(userContainer);
            continue;
          }

          // Find the most active visible day
          const maxValue = Math.max(...visibleDayValues);
          const mostActiveDayIndex = visibleDayValues.indexOf(maxValue);
          const mostActiveDay = visibleDayNames[mostActiveDayIndex];
          const mostActiveDayPercentage = (
            (maxValue / totalContributions) *
            100
          ).toFixed(1);

          // Use EXACT same color as line chart - no RGB manipulation
          const baseColor = userData.dominantColor || "#58a6ff";

          // Create day-specific opacity variations to make days easily distinguishable
          const dayOpacityMap = {
            Sunday: "F1", // Full opacity for weekend
            Monday: "62", // Lower opacity for Monday blues (0.6)
            Tuesday: "81", // Gradually increasing (0.7)
            Wednesday: "9A", // Mid-week (0.8)
            Thursday: "A2", // Almost there (0.9)
            Friday: "BD", // TGIF energy (0.95)
            Saturday: "CB", // Full opacity for weekend
          };

          const colors = visibleDayNames.map((dayName) => {
            const opacity = dayOpacityMap[dayName] || 0.8;
            return baseColor.includes("rgb")
              ? baseColor.replace(/[\d.]+\)$/, `${opacity})`)
              : `${baseColor}${opacity}`;
          });

          // Create canvas for this user
          const canvas = document.createElement("canvas");
          canvas.style.width = "100%";
          canvas.style.height = "250px";
          canvas.style.maxHeight = "250px";

          userContainer.appendChild(canvas);

          const ctx = canvas.getContext("2d");

          const chartInstance = new Chart(ctx, {
            type: "doughnut",
            data: {
              labels: visibleDayNames,
              datasets: [
                {
                  data: visibleDayValues,
                  backgroundColor: colors,
                  borderColor: baseColor,
                  borderWidth: 2,
                  hoverOffset: 6,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              cutout: "60%",
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  enabled: false,
                  external: function (context) {
                    const tooltip = context.tooltip;

                    // Create or get shared tooltip
                    let sharedTooltip = document.getElementById(
                      "shared-donut-tooltip"
                    );
                    if (!sharedTooltip) {
                      sharedTooltip = document.createElement("div");
                      sharedTooltip.id = "shared-donut-tooltip";
                      sharedTooltip.style.background = "#0d1117f2";
                      sharedTooltip.style.borderRadius = "8px";
                      sharedTooltip.style.color = "#e6edf3";
                      sharedTooltip.style.opacity = "0";
                      sharedTooltip.style.pointerEvents = "none";
                      sharedTooltip.style.position = "fixed";
                      sharedTooltip.style.padding = "8px";
                      sharedTooltip.style.fontSize = "13px";
                      sharedTooltip.style.zIndex = "1000";
                      sharedTooltip.style.border = "1px solid #30363d";
                      sharedTooltip.style.boxShadow = "0 4px 12px #00000066";
                      sharedTooltip.style.transition = "opacity 0.2s ease";
                      sharedTooltip.style.transform = "translate(-50%, -100%)";

                      document.body.appendChild(sharedTooltip);
                    }

                    // Hide if no tooltip
                    if (tooltip.opacity === 0) {
                      sharedTooltip.style.opacity = 0;
                      return;
                    }

                    // Set Text
                    if (tooltip.body && tooltip.dataPoints.length > 0) {
                      const dataPoint = tooltip.dataPoints[0];
                      const dayName = visibleDayNames[dataPoint.dataIndex];
                      const contributions = dataPoint.parsed;
                      const percentage =
                        totalContributions > 0
                          ? (
                              (contributions / totalContributions) *
                              100
                            ).toFixed(1)
                          : 0;

                      const tooltipContent = generateTooltipContent(
                        [
                          {
                            username: username,
                            contributions: `${contributions} (${percentage}%)`,
                            color: baseColor,
                          },
                        ],
                        dayName
                      );

                      sharedTooltip.innerHTML = tooltipContent;
                    }

                    // Position tooltip at mouse cursor using global coordinates
                    const canvasPosition = Chart.helpers.getRelativePosition(
                      context.chart.canvas.getBoundingClientRect(),
                      context.chart
                    );
                    const rect = context.chart.canvas.getBoundingClientRect();
                    sharedTooltip.style.left =
                      rect.left + tooltip.caretX + "px";
                    sharedTooltip.style.top = rect.top + tooltip.caretY + "px";
                    sharedTooltip.style.opacity = "1";
                  },
                },
              },
              onHover: (event, activeElements) => {
                event.native.target.style.cursor =
                  activeElements.length > 0 ? "pointer" : "default";
              },
            },
            plugins: [
              {
                id: "centerText",
                beforeDraw: function (chart) {
                  const ctx = chart.ctx;
                  const centerX =
                    chart.chartArea.left +
                    (chart.chartArea.right - chart.chartArea.left) / 2;
                  const centerY =
                    chart.chartArea.top +
                    (chart.chartArea.bottom - chart.chartArea.top) / 2;

                  // Draw most active day text in center
                  ctx.save();
                  ctx.textAlign = "center";
                  ctx.textBaseline = "middle";

                  // Draw "Most busy on" label
                  ctx.fillStyle = "#8b949e";
                  ctx.font = '12px "Segoe UI", sans-serif';
                  ctx.fillText("Most busy on", centerX, centerY - 10);

                  // Draw the day and percentage
                  ctx.fillStyle = baseColor;
                  ctx.font = 'bold 14px "Segoe UI", sans-serif';
                  ctx.fillText(
                    `${mostActiveDay} (${mostActiveDayPercentage}%)`,
                    centerX,
                    centerY + 10
                  );
                  ctx.restore();
                },
              },
            ],
          });

          donutChartInstances.push(chartInstance);
          gridContainer.appendChild(userContainer);
        }
      }

      // Helper function to convert hex to rgba (8-digit hex)
      function hexToRgba(hex, alpha) {
        const rgb = hexToRgb(hex);
        if (!rgb) return hex;
        const alphaHex = Math.round(alpha * 255)
          .toString(16)
          .padStart(2, "0");
        return `#${rgb.r.toString(16).padStart(2, "0")}${rgb.g
          .toString(16)
          .padStart(2, "0")}${rgb.b.toString(16).padStart(2, "0")}${alphaHex}`;
      }

      // Function to render global toggleable donut chart legend
      function renderGlobalDonutLegend() {
        const legendContainer = document.getElementById("chartLegend");
        legendContainer.innerHTML = "";
        legendContainer.style.flexDirection = "row";
        legendContainer.style.gap = "16px";
        legendContainer.style.justifyContent = "center";
        legendContainer.style.flexWrap = "wrap";

        const dayNames = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];
        const dayAbbrevs = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

        dayNames.forEach((dayName, index) => {
          const dayItem = document.createElement("div");
          dayItem.className = "legend-item";
          dayItem.dataset.day = dayName;
          dayItem.style.padding = "8px 12px";
          dayItem.style.borderRadius = "8px";
          dayItem.style.background = "#30363d4d";
          dayItem.style.minWidth = "50px";
          dayItem.style.textAlign = "center";
          dayItem.style.cursor = "pointer";
          dayItem.style.transition = "all 0.2s ease";
          dayItem.style.border = "2px solid transparent";
          dayItem.style.fontSize = "12px";
          dayItem.style.fontWeight = "500";
          dayItem.style.color = "#e6edf3";

          // Apply hidden state if day is hidden
          if (hiddenDays.has(dayName)) {
            dayItem.classList.add("hidden");
            dayItem.style.opacity = "0.4";
            dayItem.style.background = "#30363d1a";
            dayItem.style.color = "#6e7681";
          }

          dayItem.textContent = dayAbbrevs[index];

          // Add click handler to toggle day visibility
          dayItem.addEventListener("click", () => {
            if (hiddenDays.has(dayName)) {
              hiddenDays.delete(dayName);
              dayItem.classList.remove("hidden");
              dayItem.style.opacity = "1";
              dayItem.style.background = "#30363d4d";
              dayItem.style.color = "#e6edf3";
            } else {
              hiddenDays.add(dayName);
              dayItem.classList.add("hidden");
              dayItem.style.opacity = "0.4";
              dayItem.style.background = "#30363d1a";
              dayItem.style.color = "#6e7681";
            }
            // Re-render all donut charts
            updateChart();
          });

          // Hover effects
          dayItem.addEventListener("mouseenter", () => {
            if (!hiddenDays.has(dayName)) {
              dayItem.style.background = "#58a6ff33";
              dayItem.style.borderColor = "#58a6ff66";
            }
          });

          dayItem.addEventListener("mouseleave", () => {
            if (!hiddenDays.has(dayName)) {
              dayItem.style.background = "#30363d4d";
              dayItem.style.borderColor = "transparent";
            }
          });

          legendContainer.appendChild(dayItem);
        });
      }

      function showMetrics(data) {
        const total = data.reduce((sum, item) => sum + item.contributions, 0);
        const average = Math.round((total / data.length) * 10) / 10;
        const maxContributions = data.reduce(
          (max, item) => Math.max(max, item.contributions),
          0
        );
        const mostActiveDay = data.find(
          (item) => item.contributions === maxContributions
        );
        const activeDays = data.filter((item) => item.contributions > 0).length;
        const streaks = calculateStreaks(data);

        // Format the most active day with month
        let mostActiveDayDisplay = "N/A";
        if (mostActiveDay) {
          const date = new Date(mostActiveDay.date);
          const options = { month: "short", day: "numeric" };
          mostActiveDayDisplay = date.toLocaleDateString("en-US", options);
        }

        const metricsSection = document.getElementById("metricsSection");
        metricsSection.innerHTML = `
                <div class="metric-card">
                    <i data-lucide="trending-up" class="metric-icon"></i>
                    <div class="metric-value">${total}</div>
                    <div class="metric-label">Total Contributions</div>
                </div>
                <div class="metric-card">
                    <i data-lucide="bar-chart-3" class="metric-icon"></i>
                    <div class="metric-value">${average}</div>
                    <div class="metric-label">Daily Average</div>
                </div>
                <div class="metric-card">
                    <i data-lucide="flame" class="metric-icon"></i>
                    <div class="metric-value">${mostActiveDayDisplay}</div>
                    <div class="metric-label">Most Active Day</div>
                    <div class="metric-subtitle">(${maxContributions} contributions)</div>
                </div>
                <div class="metric-card">
                    <i data-lucide="calendar-days" class="metric-icon"></i>
                    <div class="metric-value">${streaks.currentStreak}</div>
                    <div class="metric-label">Current Streak</div>
                    <div class="metric-subtitle">days</div>
                </div>
                <div class="metric-card">
                    <i data-lucide="trophy" class="metric-icon"></i>
                    <div class="metric-value">${streaks.maxStreak}</div>
                    <div class="metric-label">Longest Streak</div>
                    <div class="metric-subtitle">days</div>
                </div>
            `;

        // Initialize Lucide icons
        lucide.createIcons();
      }

      // Legacy function for compatibility
      function showStats(data) {
        showMetrics(data);
      }

      function showComparisonStats() {
        if (usersData.size < 2) {
          document.getElementById("comparisonStats").style.display = "none";
          return;
        }

        // Calculate stats for all users
        const userStats = new Map();
        for (const [username, userData] of usersData) {
          const data = userData.filteredContributions;
          const maxContributions = data.reduce(
            (max, item) => Math.max(max, item.contributions),
            0
          );
          const bestDay = data.find(
            (item) => item.contributions === maxContributions
          );
          const streaks = calculateStreaks(data);

          // Format best day with month
          let bestDayFormatted = "N/A";
          if (bestDay) {
            const date = new Date(bestDay.date);
            bestDayFormatted =
              date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
              }) + ` (${maxContributions})`;
          }

          userStats.set(username, {
            total: data.reduce((sum, item) => sum + item.contributions, 0),
            average:
              Math.round(
                (data.reduce((sum, item) => sum + item.contributions, 0) /
                  data.length) *
                  10
              ) / 10,
            maxContributions: maxContributions,
            bestDay: bestDayFormatted,
            activeDays: data.filter((item) => item.contributions > 0).length,
            currentStreak: streaks.currentStreak,
            maxStreak: streaks.maxStreak,
          });
        }

        // Create comparison table with all users
        const usernames = Array.from(usersData.keys());
        const comparisonTable = document.getElementById("comparisonTable");

        let headerHTML = "<tr><th>Metric</th>";
        usernames.forEach((username) => {
          headerHTML += `<th>${username}</th>`;
        });
        headerHTML += "</tr>";

        let bodyHTML = "";
        const metrics = [
          { key: "total", label: "Total Contributions", icon: "trending-up" },
          { key: "average", label: "Daily Average", icon: "bar-chart-3" },
          { key: "bestDay", label: "Best Day", icon: "flame" },
          { key: "activeDays", label: "Active Days", icon: "zap" },
          {
            key: "currentStreak",
            label: "Current Streak",
            icon: "calendar-days",
          },
          { key: "maxStreak", label: "Longest Streak", icon: "trophy" },
        ];

        metrics.forEach((metric) => {
          bodyHTML += `<tr><td><i data-lucide="${metric.icon}" style="width: 16px; height: 16px; margin-right: 8px; vertical-align: middle;"></i>${metric.label}</td>`;
          usernames.forEach((username) => {
            let value = userStats.get(username)[metric.key];
            if (metric.key === "average") {
              value = value.toFixed(1);
            } else if (
              metric.key === "currentStreak" ||
              metric.key === "maxStreak"
            ) {
              value = `${value} days`;
            }
            bodyHTML += `<td>${value}</td>`;
          });
          bodyHTML += "</tr>";
        });

        comparisonTable.innerHTML = `
                <div class="table-scroll-container">
                    <table class="comparison-table">
                        <thead>${headerHTML}</thead>
                        <tbody>${bodyHTML}</tbody>
                    </table>
                </div>
            `;

        document.getElementById("comparisonStats").style.display = "block";

        // Initialize Lucide icons
        lucide.createIcons();
      }

      function showChart() {
        document.getElementById("chartContainer").classList.add("active");
      }

      function showLoading(show) {
        const loadingEl = document.getElementById("loading");
        if (loadingEl) {
          loadingEl.style.display = show ? "block" : "none";
        }
      }

      function setButtonLoading(isLoading) {
        const button = document.getElementById("loadProfileBtn");
        const icon = document.getElementById("loadProfileIcon");

        if (isLoading) {
          button.disabled = true;
          button.style.opacity = "0.8";
          icon.setAttribute("data-lucide", "loader-2");
          icon.style.animation = "spin 1s linear infinite";
          button.childNodes[2].textContent = "Loading contribution data...";
        } else {
          button.disabled = false;
          button.style.opacity = "1";
          icon.setAttribute("data-lucide", "github");
          icon.style.animation = "none";
          button.childNodes[2].textContent = "Load Profile";
        }

        // Re-initialize icons after changing data-lucide attribute
        lucide.createIcons();
      }

      function showError(message) {
        const errorDiv = document.getElementById("error");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
      }

      function hideError() {
        document.getElementById("error").style.display = "none";
      }

      // Allow Enter key to trigger search
      document
        .getElementById("githubHandle")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            fetchContributions();
          }
        });

      // Allow Enter key to trigger comparison
      document
        .getElementById("compareHandle")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            fetchComparisonData();
          }
        });

      // Initialize Lucide icons and focus input when page loads
      document.addEventListener("DOMContentLoaded", function () {
        lucide.createIcons();

        // Auto-focus the username input
        const usernameInput = document.getElementById("githubHandle");
        if (usernameInput) {
          usernameInput.focus();
        }
      });
    </script>
  </body>
</html>
